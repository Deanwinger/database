# 高性能MySQL的学习笔记

## 第五章 创建高性能的索引
### 5.1 索引基础
#### 5.1.1 索引的类型
1. B-Tree 索引
    - B-Tree 意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同；
    - 叶子节点指向被索引的数据；
    - InnoDB 使用的是B+Tree；
    - B-Tree索引的查询类型：
    ~~~
        （1）全值匹配
        （2）匹配最左列
        （3）匹配列前缀
        （4）匹配范围值
        （5）精确匹配某一列并范围匹配另外一列
        （6）只访问索引的查询（覆盖索引）
    ~~~
    - B-Tree索引的限制：
    ~~~
        （1）如果不是按索引的最左列查找，则无法使用索引
        （2）不能跳过索引中的列
        （3）如果查询中有某个列的范围查询， 则其右边所有的列都无法使用索引
    ~~~

2. 哈希索引；
    - `待完成`

3. 空间数据索引（R-Tree）
    - MyISAM支持空间索引， 可以用于地理数据存储。

4. 全文索引
    - 类似于搜素引擎在做的事情。第七章有更多的细节。

### 5.2 索引的优点
- 索引大大减少了服务器需要扫描的数据量；
- 索引可以帮助服务器避免排序和临时表
- 索引可以将随机`I/O`变成顺序`I/O`；

### 5.3 高性能的索引策略
####5.3.1 独立的列
- 指索引列不能是表达式的一部分， 也不能是函数的参数；

####5.3.2 前缀索引和索引选择性
1. 基本常识
- 通常可以索引开始的部分字符，这样可以节约索引空间，提高效率， 对于BLOB，TEXT或者很长的varchar类型的列， 必须使用前缀索引；
- 索引的选择性：不重复的索引值和数据表的记录总数的比值；
- 诀窍是选择足够长的前缀保证较高的选择性，为了决定前缀的合适长度， 需要找到最常见的值的列表(见P190页的示例：`很重要`)

2. 缺陷：
- mysql无法使用前缀索引做order by和group by， 也无法使用前缀索引做覆盖扫描；】 

####5.3.3 多列索引
- P157的例子， 在MySQL 5.0和更新的版本中， 查询能够同时使用这两个单列索引进行扫描， 并将结果进行合并； 这种算法有三个变种： OR条件的联合（union），AND条件的相交（intersecion）， 组合前两种情况的联合与相交；
- 索引合并策略有时候是一种优化的结果，但实际上更多时候说明了表上的索引建的很糟糕；
- 如果在EXPLAIN中看到有索引合并，应该好好检察一下查询和表的结构， 看是不是已经是最优的，也可以通过参数optimizer_switch来关闭索引合并功能， 也可以使用IGNORE INDEX提示让优化器忽略掉某些索引；

####5.3.4 选择核实的索引列顺序
- 在一个多列B-Tree索引中， 索引列的顺序意味着索引首先按照最左列进行排序， 其次是第二列， 一个经验法则：
~~~
    将选择性最高的列放到索引最前列（当不需要考虑排序和分组时）， 通常是很好的；
~~~
- P161的例子非常值得一看；

#### 5.3.5 聚簇索引

##### 1. 基础知识
- 并不是一种单独的索引类型， 而是一种数据存储方式；

- 存储引擎负责实现索引；

- InnoDB的聚簇索引实际上在同一个结构中保存了BTree索引和数据行， 当表有聚簇索引时， 它的数据行实际上存放在索引的叶子页， 因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引， InnoDB 将通过逐渐聚集数据， 如果没有定义主键时， InnoDB 会选择一个唯一的非空索引代替， 如果还没有，InnoDB会隐式定义一个主键来作为聚簇索引；

- InnoDB 通过主键聚集数据， 这也就是说明索引的列就是`主键列`

- 聚集的数据有一些重要的优点：
~~~
    (1). 可以把相关数据保存在一起；
    (2). 数据访问更快；
    (3). 使用覆盖索引扫描的查询可以直接使用页节点中的主键值；
~~~
- 聚集的数据有一些重要的缺点：
~~~
    (1). 极大的提高了I/O密集型应用的性能， 但如果数全部放在内存中， 则访问顺序就没有那么重要了， 聚簇索引就没有什么优势了；
    (2). 插入数据严重依赖插入顺序， 按照主键的顺序插入是加载数据到InnoDB表中速度最快的， 如果不是按照主键顺序加载数据， 那么在加载完成后最好使用OPTIMIZE TABLE命令重新组织一下表；
    (3). 更新聚簇索引列的代价很高， 因为会强制InnoDB将每个被更新的行移动到新的位置；
    (4). 在插入新行， 或者主键被更新导致需要移动行的时候， 可能面临“页分裂”的问题， 会导致表占用更多的磁盘空间；
    (5). 可能导致全表扫描变慢， 尤其是行比较稀疏， 或者由于页分裂导致数据存储不连续时；
    (6). 二级索引(非聚簇索引)可能比想象的大， 因为在二级索引的叶子节点包含了引用行的主键列；
    (7). 二级索引访问需要两次索引查找， 而不是一次（二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值， 换来的好处是，InnoDB在移动时无需更新二级索引中的这个“指针”）；
~~~

- 在InnoDB中， 聚簇索引就是表，每个叶子节点都包含了主键值， 事务ID、用于事务和MVCC的回滚指针以及所有的剩余列；如果主键是列前缀索引， InnoDB也会包含完整的主键列和剩下的其他列；

##### 2. 在InnoDB表中按主键顺序插入行
- 如果正在使用的InnoDB表并没有什么数据需要聚集，可以定义一个代理键作主键，最简单的就是使用AUTO_INCREMENT自增列， 这样， 可以保证数据行是按顺序写入；

- 最好是避免随机的聚簇索引， 特别是IO密集型应用，从性能的角度来说， 使用UUID来作为聚簇索引是很糟糕的： 它使得聚簇索引的插入变得完全随机， 这是最坏的情况， 使得数据没有任何聚集特性；

- P168页中的例子值得一看，总结：使用InnoDB时应该尽可能的按主键顺序插入数据， 并尽可能的使用单调增加的聚簇键来插入新行；


#### 5.3.6 覆盖索引
1. 定义：
    - 如果一个索引包含（覆盖）所有需要查询的字段的值， 我们就称之为“覆盖索引”；
    - 不是所有类型的索引都可以成为覆盖索引，覆盖索引必须要存储索引列的值， 而哈希索引， 空间索引和全文索引等都不存储索引列的值；

2. 优势：
    - 可极大的减少数据访问量，更小的数据量， 更容易全部放入内存中，；
    - 索引是按照列值顺序存储的， 范围查询更有效；
    - 一些存储引擎如MyISAM在内存中只缓存索引， 数据则依赖操作系统来缓存， 因此要访问一次系统调用，有可能导致严重的性能问题；
    - InnoDB特别有效，因为避免了对主键索引的二次查询；

3. 说明
    - `当发起一个索引覆盖的查询时，在explain 的Extra列， 可以看到“Using index”的信息，type列和覆盖索引毫无关系， 它只是表示这个查询_访问数据的方式；`P172的例子值得一看；
    - MySQL不能在索引中执行LIKE操作，这是底层存储引擎API的限制，MySQL目前只允许在索引中做简单的比较操作，（例如：'=', '<', '>'），MySQL能在索引中做最左前缀匹配的LIKE比较，因为该操作可以转换成简单的比较操作，　如果是通配符开头的LIKE查询，则不行
    - `延迟查询`P173的例子
    - InnoDB的二级索引的叶子节点都包含了主键的值，可以有效的利用这些额外的`主键列`来覆盖查询；

#### 5.3.7 使用索引扫描来做排序
- MySQL有两种方式可以生成有序的结果：
~~~
    (1). 通过排序操作；
    (2). 按索引顺序扫描： 
        - 如果explain 出来的type列的值为“index”， 则说明MySQL使用了索引扫描来做排序；
        - 扫描索引本身是很快的，因为只需要从一条索引记录移动到紧接着的下一条，但如果索引不能覆盖查询所需的列，那就不得不每扫描一条索引记录，就会标查询一次对应的行，这基本上是随机IO， 因此，按索引顺序读取数据的速度通常要比顺序的全表扫描慢，尤其是在IO密集型的工作负载时；
        - 只有当索引的列顺序和order by字句的顺序完全一致， 并且所有列的排序方向（倒序或者是正序）都一样时, mysql才能使用索引来对结果排序；
        - 如果查询需要关联多张表，则只有当order by子句引用的字段全部为第一个表时，才能使用索引做排序（order by 子句和查找性查询的限制是一样的： 需要满足索引的最左前缀的要求）；
    （3）. P176的例子非常值得一看
~~~    

#### 5.3.8 压缩（前缀压缩）索引
- MyISAM 使用前缀压缩来减少索引的大小（默认只压缩字符串，但通过参数设置可以对整数进行压缩）；
- 压缩块使用更少的空间，代价是某些操作可能更慢（具体见P178）；
- 可以在create table语句中指定pack_keys参数来控制索引压缩方式；

#### 5.3.9 冗余和重复索引
1. 重复索引的定义：
    ~~~
    在相同的列上按相同的顺序创建的相同类型的索引；应该避免这样创建重复索引， 发现后应该立即移除；
    ~~~
    - MySQL允许在相同的列上创建多个索引；
    - 除非是在同一列上创建不同类型的索引来满足不同的查询需求；
2. 冗余索引：
    ~~~
    如果创建了索引（A，B）， 再创建索引A就是冗余索引；
    ~~~
    - 大多数情况下我们都不需要冗余索引；
    - P179例子 to be finished

#### 5.3.10 未使用的索引
- 可能有一些永远不会用到的索引，这样的索引完全是累赘，建议删除；

#### 5.3.11 索引和锁
- 可能有一些永远不会用到的索引，这样的索引完全是累赘，建议删除；

- P182的例子值得一看；
- 如果不能使用索引查找和锁定行的话，MySQL会做全表扫描并锁住所有的行；
- InnoDB在二级索引上使用共享（读）锁，但访问主键索引需要排他（写）锁， 这消除了使用覆盖索引的可能性；

### 5.4 索引案例学习
#### 5.4.1 支持多种过滤条件
- 建议将（sex，country）列作为前缀， 理由：
~~~
    (1). 几乎所有的查询都会用到sex；
    (2). 即使查询没有使用sex列也可以绕过，In()函数技巧， 见P183；
~~~
#### 5.4.2 避免多个范围条件

#### 5.4.3 优化排序
- to be finished (没看懂)

### 5.5 维护索引和表
- 维护表有三个主要的目的：
~~~
    (1).找到并修复损坏的表;
    (2).维护准确的索引信息；
    (3).减少碎片；
~~~

#### 5.5.1 找到并修复损坏的表
- CHECK TABLE可以检查出大多数的表和索引的错误；

#### 5.5.2 更新索引统计信息
- InnoDB会在表首次打开， 或者执行ANALYZE TABLE， 抑或表的大小发生非常大的变化（大小变化超过16分之一或者新插入了20亿行）的时候计算索引的统计信息；

#### 5.5.3 减少索引和数据的碎片
- 数据存储的碎片化比索引更加复杂， 有三种类型的数据碎片：
~~~
    （1）. 行碎片
    （2）. 行间碎片
    （3）. 剩余空间碎片
~~~
