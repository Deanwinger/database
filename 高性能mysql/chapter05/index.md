# 高性能MySQL的学习笔记

## 第五章 创建高性能的索引
### 5.1 索引基础
#### 5.1.1 索引的类型
1. B-Tree 索引
    - B-Tree 意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同；
    - 叶子节点指向被索引的数据；
    - InnoDB 使用的是B+Tree；
    - B-Tree索引的查询类型：
    ~~~
        （1）全值匹配
        （2）匹配最左列
        （3）匹配列前缀
        （4）匹配范围值
        （5）精确匹配某一列并范围匹配另外一列
        （6）只访问索引的查询（覆盖索引）
    ~~~
    - B-Tree索引的限制：
    ~~~
        （1）如果不是按索引的最左列查找，则无法使用索引
        （2）不能跳过索引中的列
        （3）如果查询中有某个列的范围查询， 则其右边所有的列都无法使用索引
    ~~~

2. 哈希索引；
    - `待完成`

3. 空间数据索引（R-Tree）
    - MyISAM支持空间索引， 可以用于地理数据存储。

4. 全文索引
    - 类似于搜素引擎在做的事情。第七章有更多的细节。

### 5.2 索引的优点
- 索引大大减少了服务器需要扫描的数据量；
- 索引可以帮助服务器避免排序和临时表
- 索引可以将随机`I/O`变成顺序`I/O`；

### 5.3 高性能的索引策略
####5.3.1 独立的列
- 指索引列不能是表达式的一部分， 也不能是函数的参数；

####5.3.2 前缀索引和索引选择性
1. 基本常识
- 通常可以索引开始的部分字符，这样可以节约索引空间，提高效率， 对于BLOB，TEXT或者很长的varchar类型的列， 必须使用前缀索引；
- 索引的选择性：不重复的索引值和数据表的记录总数的比值；
- 诀窍是选择足够长的前缀保证较高的选择性，为了决定前缀的合适长度， 需要找到最常见的值的列表(见P190页的示例：`很重要`)

2. 缺陷：
- mysql无法使用前缀索引做order by和group by， 也无法使用前缀索引做覆盖扫描；】 

####5.3.3 多列索引
- P157的例子， 在MySQL 5.0和更新的版本中， 查询能够同时使用这两个单列索引进行扫描， 并将结果进行合并； 这种算法有三个变种： OR条件的联合（union），AND条件的相交（intersecion）， 组合前两种情况的联合与相交；
- 索引合并策略有时候是一种优化的结果，但实际上更多时候说明了表上的索引建的很糟糕；
- 如果在EXPLAIN中看到有索引合并，应该好好检察一下查询和表的结构， 看是不是已经是最优的，也可以通过参数optimizer_switch来关闭索引合并功能， 也可以使用IGNORE INDEX提示让优化器忽略掉某些索引；

####5.3.4 选择核实的索引列顺序
- 在一个多列B-Tree索引中， 索引列的顺序意味着索引首先按照最左列进行排序， 其次是第二列， 一个经验法则：
~~~
    将选择性最高的列放到索引最前列（当不需要考虑排序和分组时）， 通常是很好的；
~~~
- P161的例子非常值得一看；

####5.3.5 聚簇索引


###### P199 to be continued
