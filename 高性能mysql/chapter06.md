# 高性能MySQL的学习笔记

## 第六章 查询优化
- 查询优化、索引优化、库表结构优化需要齐头并进；

### 6.1 为什么查询会慢
- 查询的生命周期大致可以按照顺序来看：
~~~
    从客户端，到服务器，然后在服务器上进行解析，生成执行计划，执行（最重要环节），并返回结果给客户端；
~~~

### 6.2 慢查询基础： 优化数据访问
- 大部分性能低下的查询都可以通过减少访问的数据量的方式进行优化, 步骤：
~~~
    1. 确认应用程序是否再检索大量超过需要的数据;
    2. 确认Mysql服务层是否在分析大量超过需要的数据行;
~~~

#### 6.2.1 是否向数据库请求了不需要的数据
- 典型案例
~~~
    P197的例子值得一看
    1. 查询不需要的记录
    最简单有效的方法就是再这样的查询后面加上LIMIT;

    2. 多表关联时返回全部列
    只取需要的列

    3.总是取出全部列

    4.重复查询相同的数据
~~~

#### 6.2.3 mysql是否在扫描额外的记录
- 最简单的查询开销的三个指标如下：
~~~
    1.响应时间
        a. 响应时间是两部分之和：服务时间和排队时间;
        b. 可使用“快速上限估计”法来估算查询的响应时间;
    2.扫描的行数
        a. mysql有好几种访问方式查找并返回一行结果;
        b. 在explain语句中的type列反映了访问类型,从全表扫描(all)，索引扫描（ref），范围扫描，唯一索引查询，常数引用等;
        c. 如果查询没有办法找到合适的访问类型，通常可以可以增加一个合适的索引;
        d. 一般MySQL能够使用如下三种方式应用where条件，从好到坏依次为:
            - 在索引中使用where条件来过滤不匹配的记录，这是在存储引擎层完成的；
            - 使用索引覆盖扫描（在extra列出现using index），直接从索引中过滤不需要的记录并返回命中结果，这在MySQL服务器层完成的，但无须再回表查询记录；
            - 从数据表中返回数据，然后过滤不满足条件的记录（在extra列中出现using where），在MySQL服务器层完成的，MySQL需要先从数据表读出记录然后过滤；
    3.返回的行数 
~~~

- 优化方案
~~~
    1. 使用索引覆盖扫描，把所有需要用的列都放到索引中；
    2. 改变库表结构，例如使用单独的汇总表；
    3. 重写查询（下节主题）
~~~

### 6.3 重构查询的方式
#### 6.3.1 一个复杂的查询还是多个简单的查询

#### 6.3.2 切分查询
- 定期删除旧的数据就是一个很好的例子， P202 值得一看；

#### 6.3.3 分解关联查询


### 6.4 查询执行的基础
#### 6.4.1 mysql客户端、服务器通信协议
- 半双工， 任何时刻，要么由服务向想客户端发送数据，要么由客户端向服务器发送数据，两个动作不能同时发生；


###### P206 to be finished