# 高性能MySQL的学习笔记

## 第六章 查询优化
- 查询优化、索引优化、库表结构优化需要齐头并进；

### 6.1 为什么查询会慢
- 查询的生命周期大致可以按照顺序来看：
~~~
    从客户端，到服务器，然后在服务器上进行解析，生成执行计划，执行（最重要环节），并返回结果给客户端；
~~~

### 6.2 慢查询基础： 优化数据访问
- 大部分性能低下的查询都可以通过减少访问的数据量的方式进行优化, 步骤：
~~~
    1. 确认应用程序是否再检索大量超过需要的数据;
    2. 确认Mysql服务层是否在分析大量超过需要的数据行;
~~~

#### 6.2.1 是否向数据库请求了不需要的数据
- 典型案例
~~~
    P197的例子值得一看
    1. 查询不需要的记录
    最简单有效的方法就是再这样的查询后面加上LIMIT;

    2. 多表关联时返回全部列
    只取需要的列

    3.总是取出全部列

    4.重复查询相同的数据
~~~

#### 6.2.3 mysql是否在扫描额外的记录
- 最简单的查询开销的三个指标如下：
~~~
    1.响应时间
        a. 响应时间是两部分之和：服务时间和排队时间;
        b. 可使用“快速上限估计”法来估算查询的响应时间;
    2.扫描的行数
        a. mysql有好几种访问方式查找并返回一行结果;
        b. 在explain语句中的type列反映了访问类型,从全表扫描(all)，索引扫描（ref），范围扫描，唯一索引查询，常数引用等;
        c. 如果查询没有办法找到合适的访问类型，通常可以可以增加一个合适的索引;
        d. 一般MySQL能够使用如下三种方式应用where条件，从好到坏依次为:
            - 在索引中使用where条件来过滤不匹配的记录，这是在存储引擎层完成的；
            - 使用索引覆盖扫描（在extra列出现using index），直接从索引中过滤不需要的记录并返回命中结果，这在MySQL服务器层完成的，但无须再回表查询记录；
            - 从数据表中返回数据，然后过滤不满足条件的记录（在extra列中出现using where），在MySQL服务器层完成的，MySQL需要先从数据表读出记录然后过滤；
    3.返回的行数 
~~~

- 优化方案
~~~
    1. 使用索引覆盖扫描，把所有需要用的列都放到索引中；
    2. 改变库表结构，例如使用单独的汇总表；
    3. 重写查询（下节主题）
~~~

### 6.3 重构查询的方式
#### 6.3.1 一个复杂的查询还是多个简单的查询

#### 6.3.2 切分查询
- 定期删除旧的数据就是一个很好的例子， P202 值得一看；

#### 6.3.3 分解关联查询


### 6.4 查询执行的基础
#### 6.4.1 mysql客户端、服务器通信协议
- 半双工， 任何时刻，要么由服务向想客户端发送数据，要么由客户端向服务器发送数据，两个动作不能同时发生；
- SHOW FULL PROCESSLIST, 查询一个查询生命周期中， 状态会变化很多次：
~~~
    a. sleep
    b. query
    c. locked
    d. analyzing and statistics
    e. copying  to tmp table
    f. sorting result
    g. sending data
~~~

#### 6.4.2 查询缓存

#### 6.4.3 查询优化处理
~~~
    1. 语法解析器和预处理：
        语法树是否合法
    2. 查询优化器：
        a.优化器将语法树转化成执行计划；
        b.一条查询可有有很多执行方式，优化器将选择最好的执行计划， MySQL使用的是基于成本的优化器；
        c.可以通过查询当前会话的last_query_cost的值来得知MySQL计算当前查询的成本（优化器评估成本时并不考虑任何层面的缓存）；
    3.  有多种原因导致MySQL优化器选择错误的执行计划：
        。。。P209共7条
    4. 优化策略可以简单的分为：
        a. 静态优化（编译时优化）
        b. 动态优化（运行时优化）
    5. mysql 能够处理的优化类型：
        a. 重新定义关联表的顺序
        b. 将外连接转化为内连接;
        c. 使用等价变化规则;
        d. 优化COUNT(), MIN()和MAX();
        e. 预估并转化为常数表达式；
        f. 覆盖索引扫描；
        g. 子查询优化；
        h. 提前终止查询；
        i. 等值传播
        j. 列表IN()的比较： mysql将IN()列表中的数据先进行排序， 然后通过二分查找的方式来确定列表中的值是否满足条件；
    6. 数据和索引的统计信息
        a. mysql中优化器根据统计信息来选择一个最优的执行计划；
    7. MySQL如果执行关联查询
        a. P214 mysql认为任何一个查询都是一次“关联”；
        b. P214 关联执行的策略： 对任何关联都执行嵌套循环关联操作； 
    8. 执行计划
        a. 左测深度优先树（数据结构）；
    9. 关联查询优化器
        a. 决定了多个表关联时的顺序；
        b. 绝大多数优化器比我们自己的判断要准确；
    10.排序优化
        a. 两次传输排序（旧版本使用）
        b. 单次传输排序（新版本使用）

~~~

#### 6.4.4 查询执行引擎
- pass

#### 6.4.5 返回结果给客户端
- pass

### 6.5 MySQL查询优化器的局限
#### 6.5.1 关联子查询
- MySQL最糟糕的一类查询是WHERE 条件中包含IN()的子查询, 例子P223；

#### 6.5.2 UNION的限制

#### 6.5.3 索引合并优化

#### 6.5.4 等值传递
- 不懂

#### 6.5.5 并行执行
- MySQL无法利用多核特性来并行执行查询

#### 6.5.6 哈希关联
- MySQL并不支持哈希关联, 但可以通过建立一个哈希索引曲线的实现哈希关联；

#### 6.5.7 松散索引扫描
- 历史原因， MySQL不支持松散索引扫描；
- Extra: using index for group_by, 表示这里将使用松散索引扫描；

#### 6.5.8 最大化和最小化优化
- P231 例子值得一看；

#### 6.5.9 在同一个表上查询和更新
- P232 例子值得一看；

### 6.6 查询优化器的提示 (hint)
- HIGH_PRIORITY 和 LOW_PRIORITY: 只是简单地控制了MySQL访问某个数据表的队列顺序；
- DELAYED
- STRAIGHT_JOIN
- SQL_SAMLL_RESULT 和 SQL_BIG_RESULT
- SQL_BUFFER_RESULT
- SQL_CACHE, SQL_NO_CACHE
- SQL_CALC_FOUND_ROWS
- FOR UPDATE, LOCK IN SHARE MODE
- USE INDEX, IGNORE INDEX, FORCE INDEX

### 6.7 优化特定类型查询
#### 6.7.1 优化COUNT()查询

#### 6.7.2 优化关联查询
- 确保ON或者USING字句中的列上有索引；
~~~
    一般来说, 只需要在关联顺序中的第二个表的相应列上创建索引, 没有用到的索引只会带来额外额负担；
~~~
- 确保任何GROUP BY 和 ORDER BY中的表达式只涉及到一个表中的列， 这样，才有可能使用索引优化这个过程；

- 升级MySQL时需注意；

#### 6.7.3 优化子查询
- `尽量使用关联查询代替`

#### 6.7.4 优化 GROUP BY 和 DISTINCT
`没看懂`
- 都可以使用索引来优化，这也是最有效的方法

- 当无法使用索引的时候，group by使用两种策略来完成：使用临时表或者文件排序来分组；

- 如果需要对关联查询做分组，并且是按照查找表中的某个列进行分组，那么通常，采用查找表的标识列分组的效率会比其他列更高；

#### 6.7.5 优化limit分页
- 优化此类分页查询的最简单的办法就是尽量使用索引覆盖扫描，而不是查询所有的列；

#### 6.7.6

#### 6.7.7

#### 6.7.8

#### 6.7.9

